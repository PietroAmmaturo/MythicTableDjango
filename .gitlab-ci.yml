variables:
    # When using dind service we need to instruct docker, to talk with the
    # daemon started inside of the service. The daemon is available with
    # a network connection instead of the default /var/run/docker.sock socket.
    #
    # The 'docker' hostname is the alias of the service container as described at
    # https://docs.gitlab.com/ee/ci/docker/using_docker_images.html#accessing-the-services
    #
    # Note that if you're using Kubernetes executor, the variable should be set to
    # tcp://localhost:2375 because of how Kubernetes executor connects services
    # to the job container
    DOCKER_HOST: tcp://docker:2375/
    # When using dind, it's wise to use the overlayfs driver for
    # improved performance.
    DOCKER_DRIVER: overlay2
    CONTAINER_IMAGE: $CI_REGISTRY_IMAGE
    CONTAINER_TAG: $CI_PIPELINE_IID-$CI_COMMIT_SHORT_SHA
    DOCKER_IMAGE: $CI_REGISTRY_IMAGE:$CI_PIPELINE_IID-$CI_COMMIT_SHORT_SHA
    DOCKER_ASPNETCORE_IMAGE: mcr.microsoft.com/dotnet/core/sdk:3.1.102-bionic
    MIGRATOR_CONTAINER_IMAGE: $CI_REGISTRY_IMAGE/migrator

stages: 
    - build
    - test
    - package
    - quality
    - containerize
    - container_scanning
    - deploy

.base-job:
  rules:
    - if: '($CI_PIPELINE_SOURCE == "merge_request_event")'
      when: never
    - if: '$CI_COMMIT_TAG =~ /^releases\/fp/'
      variables:
        NPM_MODE: "firstplayable"
    - variables:
        NPM_MODE: "production"

.deploy-job:
  rules:
    - if: '($CI_PIPELINE_SOURCE == "merge_request_event")'
      when: never
    - if: '$CI_COMMIT_TAG =~ /^releases\/fp/'
      variables:
        CLUSTER: "mythic-table-fp" 
        ENVIRONMENT: "fp" 
        DOMAIN: "fp.mythictable.com" 
    - if: ($CI_COMMIT_BRANCH == "main" || $DEPLOY_EDGE =="true")
      variables:
        CLUSTER: "mythic-table-edge-api" 
        ENVIRONMENT: "edge" 
        DOMAIN: "edge.mythictable.com" 
    - when: never

build:client:
    extends: .base-job
    image: node:12-alpine
    stage: build
    script:
        - cd html
        - npm install
        - npm run build -- --mode $NPM_MODE
    artifacts:
        name: "client-$CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA" #TODO: Consider simplifying this name as artifacts are emphemeral/only exist in the context of the pipeline 
        paths:    
            - html/dist/
        expire_in: 1h
    cache:
        key: "$CI_COMMIT_REF_SLUG"
        paths:
            - html/node_modules/
            - html/package-lock.json

build:server:
    image: $DOCKER_ASPNETCORE_IMAGE
    stage: build
    script:
        - dotnet restore --packages .nuget
        - dotnet build -c Release --no-restore --packages .nuget
    artifacts:
        name: "server-$CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA" #TODO: consider simplifying name. Is anything outside of a pipeline execution relying on these artifacts?
        paths:
            - server/src/*/bin
            - server/src/MythicTable/obj/project.assets.json
            - server/tests/*/bin
        expire_in: 1h
    cache:
        key: "$CI_COMMIT_REF_SLUG"
        paths:
            - .nuget/

test:client:
    stage: test
    image: node:12-alpine
    needs:
        - build:client
    script:
        - cd html
        - npm install
        - npm run test -- --coverage
    artifacts:
        name: "client-coverage-$CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA" #TODO clarify artifact naming
        paths:
            - html/coverage/
    cache:
        key: "$CI_COMMIT_REF_SLUG"
        paths:
            - html/node_modules/
            - html/package-lock.json #TODO figure out why this is being cached in both build/test stage. Determine why cach is being used for some things and artifacts for others

test:server:
    stage: test
    image: $DOCKER_ASPNETCORE_IMAGE
    needs:
        - build:server
    script:
        - dotnet test --collect:"XPlat Code Coverage"
    artifacts:
      name: "server-coverage-$CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA"
      paths:
        - server/tests/MythicTable.Integration.Tests/TestResults/*
        - server/tests/MythicTable.Tests/TestResults/*

test:k8syaml:
    stage: test
    image: dtzar/helm-kubectl
    environment:
        name: edge
        url: https://edge.mythictable.com
    script:
        - kubectl config set-cluster mythic-table-edge-api --server=$KUBE_URL
        - sed -i "s/<VERSION>/$CONTAINER_TAG/g" kubernetes/*/*.yaml
        - sed -i "s/<CI_ENVIRONMENT_SLUG>/$CI_ENVIRONMENT_SLUG/g" kubernetes/*/*.yaml
        - sed -i "s/<CI_PROJECT_PATH_SLUG>/$CI_PROJECT_PATH_SLUG/g" kubernetes/*/*.yaml
        - sed -i "s/<CI_DOMAIN>/edge.mythictable.com/g" kubernetes/*/*.yaml
        - sed -i "s/<CI_SCOPE>/edge/g" kubernetes/*/*.yaml
        - kubectl --token=$KUBE_TOKEN apply -f kubernetes/ --recursive --dry-run=server

upload:sonarcloud-client:
    stage: quality
    needs:
        - test:client
    image:
        name: sonarsource/sonar-scanner-cli:latest
        entrypoint: [""]
    cache:
        key: "${CI_JOB_NAME}"
        paths:
          - .sonar/cache
    script:
        - sonar-scanner -Dproject.settings="frontend-scanner.properties"

upload:sonarcloud-server:
    rules:
        - when: never
    stage: quality
    needs:
        - test:server
    image:
        name: kdvalin/sonarcloud-dotnet-scanner:latest
    script:
        - dotnet sonarscanner begin /o:mythicteam-1 /k:mythictable-backend /d:sonar.login="$SONAR_BACKEND_TOKEN" /d:sonar.host.url="$SONAR_HOST_URL" /d:sonar.cs.dotcover.reportsPaths="dotcover.html"
        - dotnet build
        - dotnet dotcover test --dcReportType=HTML --dcOutput=dotcover.html --dcFilters="+:MythicTable*;"
        - dotnet sonarscanner end /d:sonar.login="$SONAR_BACKEND_TOKEN"

package:
    extends: .deploy-job
    image: $DOCKER_ASPNETCORE_IMAGE
    stage: package
    needs:
        - build:server
        - build:client
        - test:client
        - test:server
        - test:k8syaml
    script:
        - dotnet publish -c Release --packages .nuget -o ./package server/src/MythicTable/
        - dotnet publish -c Release --packages .nuget -o ./migrator server/src/Migrator/
        - mkdir -p ./package/wwwroot
        - cp --archive ./html/dist/* ./package/wwwroot/
    artifacts:
        name: "mythictable-$CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA"
        paths:
            - package/
            - migrator/
    cache:
        key: "$CI_COMMIT_REF_SLUG"
        paths:
            - .nuget/

containerize:
    extends: .deploy-job
    stage: containerize
    image: docker:stable
    services:
        - docker:dind
    dependencies: 
        - package
    needs:
        - package
    script:
        - docker info
        - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
        - docker pull $CONTAINER_IMAGE:$CONTAINER_TAG || echo "Ignoring missing container"
        - "docker build -f Dockerfile.gitlab-ci -t $CONTAINER_IMAGE:$CONTAINER_TAG -t $CONTAINER_IMAGE:$CONTAINER_TAG ."
        - "docker push $CONTAINER_IMAGE:$CONTAINER_TAG"

containerize:migrator:
    extends: .deploy-job
    stage: containerize
    image: docker:stable
    services:
        - docker:dind
    script:
        - docker info
        - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
        - docker pull $MIGRATOR_CONTAINER_IMAGE:latest || echo "Ignoring missing container"
        - docker build -f server/src/Migrator/Dockerfile -t $MIGRATOR_CONTAINER_IMAGE:$CONTAINER_TAG -t $MIGRATOR_CONTAINER_IMAGE:latest .
        - docker push $MIGRATOR_CONTAINER_IMAGE:$CONTAINER_TAG
        - docker push $MIGRATOR_CONTAINER_IMAGE:latest

deploy:migrator:
    extends: .deploy-job
    stage: deploy
    needs:
        - containerize:migrator
    image: dtzar/helm-kubectl
    environment:
        name: $ENVIRONMENT
        url: https://$DOMAIN
    script:
        - kubectl config set-cluster $CLUSTER --server=$KUBE_URL
        - kubectl delete job/migrator || echo "Ignoring failure to delete migrator"
        - kubectl --token=$KUBE_TOKEN apply --recursive -f kubernetes/migrator
        - kubectl wait --for=condition=complete --timeout=300s job/migrator
        - kubectl delete job/migrator

deploy:service:
    extends: .deploy-job
    stage: deploy
    needs:
        - containerize
    image: dtzar/helm-kubectl
    environment:
        name: $ENVIRONMENT
        url: https://$DOMAIN
    script:
        - kubectl config set-cluster $CLUSTER --server=$KUBE_URL
        - sed -i "s/<VERSION>/$CONTAINER_TAG/g" kubernetes/service/*.yaml
        - sed -i "s/<CI_ENVIRONMENT_SLUG>/$CI_ENVIRONMENT_SLUG/g" kubernetes/service/*.yaml
        - sed -i "s/<CI_PROJECT_PATH_SLUG>/$CI_PROJECT_PATH_SLUG/g" kubernetes/service/*.yaml
        - sed -i "s/<KEY_DOMAIN>/key.mythictable.com/g" kubernetes/service/*.yaml
        - sed -i "s/<CI_DOMAIN>/$DOMAIN/g" kubernetes/service/*.yaml
        - sed -i "s/<CI_SCOPE>/$ENVIRONMENT/g" kubernetes/service/*.yaml
        - kubectl --token=$KUBE_TOKEN apply --recursive -f kubernetes/service

include:
  - template: Container-Scanning.gitlab-ci.yml

container_scanning:
  stage: container_scanning
  variables:
    GIT_STRATEGY: fetch
    DOCKERFILE_PATH: "Dockerfile.gitlab-ci"
  rules:
    - if: ($CI_COMMIT_BRANCH == "main" || $DEPLOY_EDGE =="true")
      when: always
    - if: '$CI_COMMIT_TAG =~ /^releases\/fp/'
      when: always
    - when: never
